/*
 * remainroot: a shim to trick code to run in a rootless container
 * Copyright (C) 2016 Aleksa Sarai <asarai@suse.de>
 *
 * remainroot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * remainroot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with remainroot.  If not, see <http://www.gnu.org/licenses/>.
 */

/* preload.c is the front-end for the LD_PRELOAD shim. */

#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syscall.h>
#include <fcntl.h>

#include "common.h"

/* These are generated by xxd -i from libremain.so. */
extern unsigned char libremain_so[];
extern unsigned int libremain_so_len;

/* From <include/uapi/linux/memfd.h> */
#if !defined(MFD_ALLOW_SEALING)
#	define MFD_ALLOW_SEALING 0x0002U
#endif

/* These come directly from the Linux kernel source. */
#if !defined(F_ADD_SEALS)
#	define F_LINUX_SPECIFIC_BASE 1024
#	define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)
#	define F_SEAL_SEAL   0x0001
#	define F_SEAL_SHRINK 0x0002
#	define F_SEAL_GROW   0x0004
#	define F_SEAL_WRITE  0x0008
#endif

/*
 * This create a temporary file and writes the contents of libremain.so
 * to it. The file descriptor is returned.
 */
int make_library(void)
{
	/* I have no words to describe how dumb this API is. */
	int fd = syscall(SYS_memfd_create, "memfd_create(2) is a bad API", MFD_ALLOW_SEALING);
	if (fd < 0)
		die("memfd_create failed: %m");

	/* Write the library code. */
	ssize_t n = write(fd, libremain_so, libremain_so_len);
	if (n != libremain_so_len)
		die("write failed: %m");

	/* We now seal the file descriptor to stop bad things. */
	if (fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK|F_SEAL_GROW|F_SEAL_WRITE|F_SEAL_SEAL) < 0)
		die("fcntl failed: could not seal: %m");

	return fd;
}

#define ENV_SIZE 4096

void shim_preload(int argc, char **argv)
{
	int fd = make_library();

	/*
	 * On execve, a bunch of different things happen to the file
	 * descriptors. Namely, all of the O_CLOEXEC ones are closed.
	 * However, there appear to be very few guarantees about what the
	 * resulting file descriptor numbers will be. But forget the haters,
	 * we'll just roll with it until something breaks.
	 *
	 * A proper way would be some kind of fork-exec thing with hopefully
	 * no race conditions. My money is not on this working.
	 */

	char env[ENV_SIZE] = {0};
	snprintf(env, ENV_SIZE, "LD_PRELOAD=/proc/self/fd/%d", fd);

	if (putenv(env) < 0)
		die("couldn't set %s: %m", env);

	execvp(argv[0], argv);

	/* Should never be reached. */
	die("execvp failed");
}
